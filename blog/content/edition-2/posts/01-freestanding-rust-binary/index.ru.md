+++
title = "Независимый бинанрник на Rust"
weight = 1
path = "ru/freestanding-rust-binary"
date = 2018-02-10

[extra]
chapter = "С нуля"
translators = ["MrZloHex"]
+++

Первым шагом в создании собственного ядра операционной системы - это создание исполняемого файла на Rust, который не будет подключать стандартную библиотеку. Именно это дает возможность запускать Rust код на [голом металле][bare metal] без слоя операционной системы, которая связывает железо компьютера и программы.

[bare metal]: https://en.wikipedia.org/wiki/Bare_machine

<!-- more -->

Этот блог открыто разрабатывается на [GitHub]. Если у вас есть несколько проблем или вопросов, пожалуйста откройте _issue_. Также можете оставлять комментарии [в конце файла][at the bottom]. Полный исходный код для этого поста вы можете найти [`post-01`][post branch] ветке репозитория.

[GitHub]: https://github.com/phil-opp/blog_os
[at the bottom]: #commentsний ком
[post branch]: https://github.com/phil-opp/blog_os/tree/post-01

<!-- toc -->

## Введение
Для того, чтобы написать ядро операционной системы нужен код, который независит от операционной системы и ее свойств. Это озночает, что нельзя использовать потоки, файлы, [кучу][heap], сети, случайные числа, стандартный видео-вывод или другие возможности, которые предоставляет абстракция в виде ОС или очень специфичное железо.

[heap]: https://en.wikipedia.org/wiki/Heap_(data_structure)

Это значит, что нельзя использовать большинство [стандартных библиотек Rust][Rust Standart library], но также есть еще множество других возможностей, которые предоставляет Rust и их _можно использовать_. Как пример того, что можно использовать это: [итераторы][iterators], [замыкания][closures], [соответствия по шаблону][pattern matching], [опции][option] и[результат][result], [форматирование строк][string formatting] и, конечно же, [систему владения][ownership system]. Эти функции дают возможность для написания ядра в очень выразительном и высоко-уровневом стиле без беспокойства о [неопределенном поведении][undefined behavior] или [сохранности памяти][memory safety].

[option]: https://doc.rust-lang.org/core/option/
[result]:https://doc.rust-lang.org/core/result/
[Rust standard library]: https://doc.rust-lang.org/std/
[iterators]: https://doc.rust-lang.org/book/ch13-02-iterators.html
[closures]: https://doc.rust-lang.org/book/ch13-01-closures.html
[pattern matching]: https://doc.rust-lang.org/book/ch06-00-enums.html
[string formatting]: https://doc.rust-lang.org/core/macro.write.html
[ownership system]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html
[undefined behavior]: https://www.nayuki.io/page/undefined-behavior-in-c-and-cplusplus-programs
[memory safety]: https://tonyarcieri.com/it-s-time-for-a-memory-safety-intervention

Вместо создания ядра ОС на Rust, нужно создать исполняемы файл, который мог бы запускаться без абстракции в виде ОС.

Этот пост описывает необходимые шаги для создания независимого исполняемого бинарного файла на Rust и объясняет зачем эти шаги нужны. Если вы заинтересованны тоьлько в простом примере, можете сразу перейти к __[итогам](#Итоги)__.

## Дизактивация стандартной библиотеки
По стандарту, все модули Rust ссылаются на [стандартную библиотеку][standart library], которая зависит от операционной системы для таких возможностей как потоки, файлы, сети. Также она зависит от стандартной библиотки C `libc`, которая очень тесно взаимодействует с сервиса ОС. С тех пор как план - это написание операционной системы, нельзя использовать библиотеки, которые зависят от операционной системы. Следовательно стоит отключить автоматические добавление стандартной библиотеки через [`no_std` аттрибут][attribute].

[standard library]: https://doc.rust-lang.org/std/
[attribute]: https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html

Мы начнем с создания нового cargo проекта. Самый простой способ сделать это, через командную строку:

```
cargo new blog_os --bin -- edition 2018
```

Я назвал этот проект `blog_os`, но вы можете назвать как вам угодно. Флаг `--bin` указывает на то, что мы хоти создать исполняемый бинарный файл (в сравнении с библиотекой) и флаг `--edition 2018` указывает, что мы хотим использовать [версию 2018][edition] Rust для нашего модуля. После выполнения комманды, cargo создаст каталог со следующей стркутурой:

[edition]: https://doc.rust-lang.org/nightly/edition-guide/rust-2018/index.html

```
blog_os
├── Cargo.toml
└── src
    └── main.rs
```

`Cargo.toml` содержит данные и конфигурацию модуля, такие как _название, автор, версию_ и _зависимости_ от других модулей и библиотек. Файл `src/main.rs` содержит корневой файл нашего модуля и главную `main` функцию. Можно скомпилировать модуль с помощью `cargo build` и после запустить скомпилированный `blog_os` бинарный файл в `target/debug` каталоге.

### Аттрибут `no_std`

В данный момент наш модуль не явно подключает стандартную библиотеку. Это можно испровить путем добавления [аттрибута `no_std`][attribute]:

```rust
// main.rs

#![no_std]

fn main() {
    println!("Hello, world!");
}
```

Если попробывать скомпилировать прямо сейчас (с помоцью комманды `cargo build`), то появится следующая ошибка:

```
error: cannot find macro `println!` in this scope
 --> src/main.rs:4:5
  |
4 |     println!("Hello, world!");
  |     ^^^^^^^
```

Это ошибка объясняется тем, что [макрос `println`][macro] часть стандартной библиотеки, которая была отключена. Так что больше у накс нет возможности выводить на экран что либо. Но это имеет смысл, так как `println` печатает через [стандартный поток вывода][standart output], который, в свою очередь, является специальный файлом, описанным операционной системой.

[macro]: https://doc.rust-lang.org/std/macro.println.html
[standart output]: https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29

Давайте уберем макрос `println` и попробуем скомпилировать еще раз:

```rust
// main.rs

#![no_std]

fn main() {}
```

```
> cargo build
error: `#[panic_handler]` function required, but not found
error: language item required, but not found: `eh_personality`
```

Сейчас компилятор не может найти `#[panic_handler]` функцию и _языковой предмет(`eh_personality`)_.

## Реализация _паники_

Аттрибут `pаnic_handler` определяет функцию, которая должна вызываться, когда происходит [паника (panic)][panic]. Стандартная библиотека предоставляет собственную функцию обработчика паники, но после отключения стандартной библиотеки ма должны написать собственный обработчик:

[panic]: https://doc.rust-lang.org/stable/book/ch09-01-unrecoverable-errors-with-panic.html

```rust
// in main.rs

use core::panic::PanicInfo;

/// This function is called on panic.
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

Параметр [`PanicInfo`][PanicInfo] содержит название файла, строку где произошла паника и дополнительное сообщение с пояснением. Это функцию никогда ничего не должна возвращать и такая функция называется [расходящиеся функцию][diverging functions] и она возращает ["невозможный" тип]["never" type] `!`. На данный момент у нас нет особых инструментов, которые мы бы могли использовать, чтобы заполнить это функцию, поэтому мы просто войдем в бесконечный цикл.

[PanicInfo]: https://doc.rust-lang.org/nightly/core/panic/struct.PanicInfo.html
[diverging function]: https://doc.rust-lang.org/1.30.0/book/first-edition/functions.html#diverging-functions
[“never” type]: https://doc.rust-lang.org/nightly/std/primitive.never.html

## Языковой предмет `eh_personality`

Языковые предметы это специальный функции и типы, которые необходимы компилятору. Например, трэйт [`Copy`] эхто языковой предмет, которые указывает компилятору какой тип [_семантику копирования_][`Copy`]. Если мы посмотрим на исходный код [реализации][copy code] этого трэйта, то можно увидеть специальный аттрибут `#[lang = "copy"]`, которые указывает на то, что это языковой предмет.

[`Copy`]: https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html
[copy code]: https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src/libcore/marker.rs#L296-L299

Хотя создание собственных реализаций языковых предметов возможна, это следует делать только в крайнем случае. Причина в том, что языковые предметы являются крайне нестабильными частями реализации и даже не проверяются на тип (поэтому компилятор даже не проверяет, имеет ли функция правильные типы аргументов). К счастью, существует более стабильный способ исправить вышеупомянутую ошибку языкового предмета.

Языковой предмет [`eh_personality`][language item] указывает на функцию, которая используется для реализации [раскрутки стэка][stack unwinding]. По стандарту, Rust использует раскрутку для запуска деструктуров для всех _живых_ стэковых переменных в случае появлении [паники][panic]. Это гарантирует, что вся использованная память будет освобождена, и позволяет родительскому потоку перехватить панику и продолжить выполнение. Раскрутка очень сложный процесс и требует некоторых специльных библиотек ОС (например, [libunwind] для Linux или [structured exception handling] для Windows), так что мы не должны использовать их для нашей операицонной системы.

[language item]: https://github.com/rust-lang/rust/blob/edb368491551a77d77a48446d4ee88b35490c565/src/libpanic_unwind/gcc.rs#L11-L45
[stack unwinding]: https://www.bogotobogo.com/cplusplus/stackunwinding.php
[libunwind]: https://www.nongnu.org/libunwind/
[structured exception handling]: https://docs.microsoft.com/de-de/windows/win32/debug/structured-exception-handling

### Отключение раскрутки

Существуют и другие случаи использования, для которых раскрутка нежелательна, поэтому Rust предоставляет опцию [отмены при панике][abort on panic]. Это отключает генерацию информации о символах раскрутки и, таким образом, значительно уменьшает размер двоичного файла. Есть несколько мест, где мы можем отключить раскрутку. Самый простой способ - добавить следующие строки в наш `Cargo.toml`:

```toml
[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```

Это устанавливает стратегию паники на `abort`(отмены) как для профиля `dev` (используемого для `cargo build`), так и для профиля `release` (используемого для `cargo build --release`). Теперь языковой предмет `eh_personality` больше не должен требоваться.

[abort on panic]: https://github.com/rust-lang/rust/pull/32900

Теперь мы исправили обе вышеуказанные ошибки. Однако, если мы попытаемся скомпилировать его теперь, возникнет другая ошибка:

```
> cargo build
error: requires `start` lang_item
```

В нашей программе отсутствует языковой предмет `start`, который определяет начальную точку входа в программу.

## Аттрибут `start`

Можно подумать, что функция `main` - это первая функция, вызываемая при запуске программы. Однако в большинстве языков есть [runtime система][runtime system], которая отвечает за такие вещи, как сборка мусора (например, в Java) или программные потоки (например, goroutines в Go). Эта система выполнения должна быть вызвана до `main`, поскольку ей необходимо инициализировать себя.

[runtime system]: https://en.wikipedia.org/wiki/Runtime_system

В типичном бинарном файле Rust, который использует стандартную библиотеку, выполнение начинается в библиотеке C runtime под названием `crt0` ("C runtime zero"), которая создает окружение для C приложения. Это включает создание стека и размещение аргументов в нужных регистрах. Затем C runtime вызывает [точку входа для  приложения Rust][rt::lang_start], которая обозначается языковым предметом `start`. Rust имеет только очень маленький runtime, который заботится о некоторых мелочах, таких как установка защиты от переполнения стека или вывод сообщения при панике. Затем runtime вызывает функцию `main`.

[rt::lang_start]: https://github.com/rust-lang/rust/blob/bb4d1491466d8239a7a5fd68bd605e3276e97afb/src/libstd/rt.rs#L32-L73

Наш независимый исполняемый файл не имеет доступа к runtime Rust и `crt0`, поэтому нам нужно определить собственную точку входа. Реализация языкового предмета `start` не поможет, поскольку он все равно потребует `crt0`. Вместо этого нам нужно напрямую переопределить точку входа `crt0`.

### Переопределение точки входа

Чтобы сообщить компилятору Rust, что мы не хотим использовать стандартную цепочку точек входа, мы добавляем атрибут `#![no_main]`.

```rust
#![no_std]
#![no_main]

use core::panic::PanicInfo;

/// This function is called on panic.
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

Вы можете заметить, что мы удалили функцию `main`. Причина в том, что `main` не имеет смысла без стандартнлого runtime, которая ее вызывает. Вместо этого мы переопределили точку входа операционной системы нашей собственной функцией `_start`:

```rust
#[no_mangle]
pub extern "C" fn _start() -> ! {
    loop {}
}
```

Используя атрибут `#[no_mangle]`, мы отключаем [искажение имен][name mangling], чтобы гарантировать, что компилятор Rust действительно выводит функцию с именем `_start`. Без этого атрибута компилятор генерировал бы какой-нибудь загадочный символ `_ZN3blog_os4_start7hb173fedf945531caE`, чтобы дать каждой функции уникальное имя. Атрибут необходим, потому что на следующем этапе нам нужно сообщить имя функции точки входа компоновщику.

Мы также должны пометить функцию как `extern "C"`, чтобы указать компилятору, что он должен использовать [соглашение о вызове C][C calling convention] для этой функции (вместо неопределенного соглашения о вызове Rust). Причина именования функции `_start` в том, что это имя точки входа по умолчанию для большинства систем.

[name mangling]: https://en.wikipedia.org/wiki/Name_mangling
[C calling convention]: https://en.wikipedia.org/wiki/Calling_convention

Тип возврата `!` означает, что функция является расходящейся, т.е. не имеет права возвращаться. Это необходимо, поскольку точка входа не вызывается никакой функцией, а вызывается непосредственно операционной системой или загрузчиком. Поэтому вместо возврата точка входа должна, например, вызывать [системный вызов `exit`][`exit` system call] операционной системы. В нашем случае разумным действием может быть выключение машины, поскольку в случае возврата автономного двоичного файла делать нечего. Пока что мы выполняем это требование путем бесконечного цикла.

[`exit` system call]: https://en.wikipedia.org/wiki/Exit_(system_call)

Если мы выполним `cargo build` сейчас, мы получаем ошибку компоновщика (_linker_ error).

## Ошибки компоновщика

Компоновщик - это программа, которая объединяет сгенерированный код в исполняемый файл. Поскольку формат исполняемого файла отличается в Linux, Windows и macOS, в каждой системе есть свой компоновщик, который выдает разные ошибки. Основная причина ошибок одна и та же: конфигурация компоновщика по умолчанию предполагает, что наша программа зависит от C runtime, а это не так.

Чтобы устранить ошибки, нам нужно сообщить компоновщику, что он не должен включать C runtime. Мы можем сделать это, передав компоновщику определенный набор аргументов или выполнив компиляцию для голого железа.

### Компиляция для голого железа

По умолчанию Rust пытается создать исполняемый файл, который может быть запущен в вашем текущем системном окружении. Например, если вы используете Windows на `x86_64`, Rust пытается создать исполняемый файл `.exe` Windows, который использует инструкции `x86_64`. Это окружение называется вашей "хост-системой".

Для описания различных окружений Rust использует строку [_target triple_]. Вы можете узнать тройку вашей хост-системы, выполнив команду `rustc --version --verbose`:

[_target triple_]: https://clang.llvm.org/docs/CrossCompilation.html#target-triple

```
rustc 1.35.0-nightly (474e7a648 2019-04-07)
binary: rustc
commit-hash: 474e7a6486758ea6fc761893b1a49cd9076fb0ab
commit-date: 2019-04-07
host: x86_64-unknown-linux-gnu
release: 1.35.0-nightly
LLVM version: 8.0
```

Приведенный выше результат получен от системы `x86_64` Linux. Мы видим, что тройка `host` - это `x86_64-unknown-linux-gnu`, которая включает архитектуру процессора (`x86_64`), производителя (`unknown`), операционную систему (`linux`) и [ABI] (`gnu`).

[ABI]: https://en.wikipedia.org/wiki/Application_binary_interface

Компилируя для нашей тройки хоста, компилятор Rust и компоновщик предполагают наличие базовой операционной системы, такой как Linux или Windows, которая по умолчанию использует C runtime, что вызывает ошибки компоновщика. Поэтому, чтобы избежать ошибок компоновщика, мы можем скомпилировать для другого окружения без базовой операционной системы.

Примером такого "голого" окружения является тройка `thumbv7em-none-eabihf`, которая описывает [ARM] архитектуру. Детали не важны, важно лишь то, что тройка не имеет базовой операционной системы, на что указывает `none` в тройке. Чтобы иметь возможность компилировать для этой системы, нам нужно добавить ее в rustup:

[ARM]: https://en.wikipedia.org/wiki/ARM_architecture

```
rustup target add thumbv7em-none-eabihf
```

Это загружает копию стандартной (и корневой) библиотеки для системы. Теперь мы можем собрать наш независимый исполняемый файл для этой системы:

```
cargo build --target thumbv7em-none-eabihf
```

Передавая аргумент `--target`, мы [кросс-компилируем][cross compile] наш исполняемый файл для голого железа. Поскольку система, под которую мы компилируем, не имеет операционной системы, компоновщик не пытается компоновать C runtime, и наша компиляция проходит успешно без каких-либо ошибок компоновщика.

[cross compile]: https://en.wikipedia.org/wiki/Cross_compiler

Именно этот подход мы будем использовать для сборки ядра нашей ОС. Вместо `thumbv7em-none-eabihf` мы будем использовать [custom target], который описывает `x86_64` архитектуру окружения. Подробности будут описаны в следующем посте.

[custom target]: https://doc.rust-lang.org/rustc/targets/custom.html

### Аргументы компоновщика

Вместо компиляции для голой системы можно также разрешить ошибки компоновщика, передав ему определенный набор аргументов. Мы не будем использовать этот подход для нашего ядра, поэтому данный раздел является необязательным и приводится только для полноты картины. Щелкните на _"Аргументы компоновщика"_ ниже, чтобы показать необязательное содержание.

<details>

<summary>Аргументы компоновщика</summary>


</details>

## Итоги

Минимальный независимый исполняемый бинарный файл Rust выглядит примерно так:

`src/main.rs`:

```rust
#![no_std] // don't link the Rust standard library
#![no_main] // disable all Rust-level entry points

use core::panic::PanicInfo;

#[no_mangle] // don't mangle the name of this function
pub extern "C" fn _start() -> ! {
    // this function is the entry point, since the linker looks for a function
    // named `_start` by default
    loop {}
}

/// This function is called on panic.
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

`Cargo.toml`:

```toml
[package]
name = "crate_name"
version = "0.1.0"
authors = ["Author Name <author@example.com>"]

# the profile used for `cargo build`
[profile.dev]
panic = "abort" # disable stack unwinding on panic

# the profile used for `cargo build --release`
[profile.release]
panic = "abort" # disable stack unwinding on panic
```

Для компиляции этого бинарного файла, мы должны компиляровать для голой системы, такой как `thumbv7em-none-eabihf`:

```
cargo build --target thumbv7em-none-eabihf
```

В качестве альтернативы, мы можем скомпилировать его для хост-системы, передав дополнительные аргументы компоновщика:

```bash
# Linux
cargo rustc -- -C link-arg=-nostartfiles
# Windows
cargo rustc -- -C link-args="/ENTRY:_start /SUBSYSTEM:console"
# macOS
cargo rustc -- -C link-args="-e __start -static -nostartfiles"
```

Обратите внимание, что это лишь минимальный пример независимого бинарного файла Rust. Этот бинарник ожидает различных вещей, например, что стек инициализируется при вызове функции `_start`. **Поэтому для любого реального использования такого бинарного файла требуется больше шагов разработки**.

## Что дальше?

В [следующем посте][next post] описаны шаги, необходимые для превращения нашего независимого бинарного файла в минимальное ядро операционной системы. Сюда входит создание пользовательской системы, объединение нашего исполняемого файла с загрузчиком и изучение того, как вывести что-то на экран.

[next post]: @/edition-2/posts/02-minimal-rust-kernel/index.ru.md