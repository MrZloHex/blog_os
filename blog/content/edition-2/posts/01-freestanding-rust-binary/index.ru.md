+++
title = "Независимый бинанрник на Rust"
weight = 1
path = "ru/freestanding-rust-binary"
date = 2018-02-10

[extra]
chapter = "С нуля"
translators = ["MrZloHex"]
+++

Первым шагом в создании собственного ядра операционной системы - это создание исполняемого файла на Rust, который не будет подключать стандартную библиотеку. Именно это дает возможность запускать Rust код на [голом металле][bare metal] без слоя операционной системы, которая связывает железо компьютера и программы.

[bare metal]: https://en.wikipedia.org/wiki/Bare_machine

<!-- more -->

Этот блог открыто разрабатывается на [GitHub]. Если у вас есть несколько проблем или вопросов, пожалуйста откройте _issue_. Также можете оставлять комментарии [в конце файла][at the bottom]. Полный исходный код для этого поста вы можете найти [`post-01`][post branch] ветке репозитория.

[GitHub]: https://github.com/phil-opp/blog_os
[at the bottom]: #commentsний ком
[post branch]: https://github.com/phil-opp/blog_os/tree/post-01

<!-- toc -->

## Введение
Для того, чтобы написать ядро операционной системы нужен код, который независит от операционной системы и ее свойств. Это озночает, что нельзя использовать потоки, файлы, [кучу][heap], сети, случайные числа, стандартный видео-вывод или другие возможности, которые предоставляет абстракция в виде ОС или очень специфичное железо.

[heap]: https://en.wikipedia.org/wiki/Heap_(data_structure)

Это значит, что нельзя использовать большинство [стандартных библиотек Rust][Rust Standart library], но также есть еще множество других возможностей, которые предоставляет Rust и их _можно использовать_. Как пример того, что можно использовать это: [итераторы][iterators], [замыкания][closures], [соответствия по шаблону][pattern matching], [опции][option] и[результат][result], [форматирование строк][string formatting] и, конечно же, [систему владения][ownership system]. Эти функции дают возможность для написания ядра в очень выразительном и высоко-уровневом стиле без беспокойства о [неопределенном поведении][undefined behavior] или [сохранности памяти][memory safety].

[option]: https://doc.rust-lang.org/core/option/
[result]:https://doc.rust-lang.org/core/result/
[Rust standard library]: https://doc.rust-lang.org/std/
[iterators]: https://doc.rust-lang.org/book/ch13-02-iterators.html
[closures]: https://doc.rust-lang.org/book/ch13-01-closures.html
[pattern matching]: https://doc.rust-lang.org/book/ch06-00-enums.html
[string formatting]: https://doc.rust-lang.org/core/macro.write.html
[ownership system]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html
[undefined behavior]: https://www.nayuki.io/page/undefined-behavior-in-c-and-cplusplus-programs
[memory safety]: https://tonyarcieri.com/it-s-time-for-a-memory-safety-intervention

Вместо создания ядра ОС на Rust, нужно создать исполняемы файл, который мог бы запускаться без абстракции в виде ОС.

Этот пост описывает необходимые шаги для создания независимого исполняемого бинарного файла на Rust и объясняет зачем эти шаги нужны. Если вы заинтересованны тоьлько в простом примере, можете сразу перейти к __[итогам](#Итоги)__.

## Дизактивация стандартной библиотеки
По стандарту, все модули Rust ссылаются на [стандартную библиотеку][standart library], которая зависит от операционной системы для таких возможностей как потоки, файлы, сети. Также она зависит от стандартной библиотки C `libc`, которая очень тесно взаимодействует с сервиса ОС. С тех пор как план - это написание операционной системы, нельзя использовать библиотеки, которые зависят от операционной системы. Следовательно стоит отключить автоматические добавление стандартной библиотеки через [`no_std` аттрибут][attribute].

[standard library]: https://doc.rust-lang.org/std/
[attribute]: https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html

Мы начнем с создания нового cargo проекта. Самый простой способ сделать это, через командную строку:

```
cargo new blog_os --bin -- edition 2018
```

Я назвал этот проект `blog_os`, но вы можете назвать как вам угодно. Флаг `--bin` указывает на то, что мы хоти создать исполняемый бинарный файл (в сравнении с библиотекой) и флаг `--edition 2018` указывает, что мы хотим использовать [версию 2018][edition] Rust для нашего модуля. После выполнения комманды, cargo создаст каталог со следующей стркутурой:

[edition]: https://doc.rust-lang.org/nightly/edition-guide/rust-2018/index.html

```
blog_os
├── Cargo.toml
└── src
    └── main.rs
```

`Cargo.toml` содержит данные и конфигурацию модуля, такие как _название, автор, версию_ и _зависимости_ от других модулей и библиотек. Файл `src/main.rs` содержит корневой файл нашего модуля и главную `main` функцию. Можно скомпилировать модуль с помощью `cargo build` и после запустить скомпилированный `blog_os` бинарный файл в `target/debug` каталоге.

### Аттрибут `no_std`

В данный момент наш модуль не явно подключает стандартную библиотеку. Это можно испровить путем добавления [аттрибута `no_std`][attribute]:

```rust
// main.rs

#![no_std]

fn main() {
    println!("Hello, world!");
}
```

Если попробывать скомпилировать прямо сейчас (с помоцью комманды `cargo build`), то появится следующая ошибка:

```
error: cannot find macro `println!` in this scope
 --> src/main.rs:4:5
  |
4 |     println!("Hello, world!");
  |     ^^^^^^^
```

Это ошибка объясняется тем, что [макрос `println`][macro] часть стандартной библиотеки, которая была отключена. Так что больше у накс нет возможности выводить на экран что либо. Но это имеет смысл, так как `println` печатает через [стандартный поток вывода][standart output], который, в свою очередь, является специальный файлом, описанным операционной системой.

[macro]: https://doc.rust-lang.org/std/macro.println.html
[standart output]: https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29

Давайте уберем макрос `println` и попробуем скомпилировать еще раз:

```rust
// main.rs

#![no_std]

fn main() {}
```

```
> cargo build
error: `#[panic_handler]` function required, but not found
error: language item required, but not found: `eh_personality`
```

Сейчас компилятор не может найти `#[panic_handler]` функцию и _языковой предмет(`eh_personality`)_.

## Реализация _паники_

Аттрибут `pаnic_handler` определяет функцию, которая должна вызываться, когда происходит [паника (panic)][panic]. Стандартная библиотека предоставляет собственную функцию обработчика паники, но после отключения стандартной библиотеки ма должны написать собственный обработчик:

[panic]: https://doc.rust-lang.org/stable/book/ch09-01-unrecoverable-errors-with-panic.html

```rust
// in main.rs

use core::panic::PanicInfo;

/// This function is called on panic.
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

Параметр [`PanicInfo`][PanicInfo] содержит название файла, строку где произошла паника и дополнительное сообщение с пояснением. Это функцию никогда ничего не должна возвращать и такая функция называется [расходящиеся функцию][diverging functions] и она возращает ["невозможный" тип]["never" type] `!`. На данный момент у нас нет особых инструментов, которые мы бы могли использовать, чтобы заполнить это функцию, поэтому мы просто войдем в бесконечный цикл.

[PanicInfo]: https://doc.rust-lang.org/nightly/core/panic/struct.PanicInfo.html
[diverging function]: https://doc.rust-lang.org/1.30.0/book/first-edition/functions.html#diverging-functions
[“never” type]: https://doc.rust-lang.org/nightly/std/primitive.never.html

## Языковой предмет `eh_personality`

Языковые предметы это специальный функции и типы, которые необходимы компилятору. Например, трэйт [`Copy`] эхто языковой предмет, которые указывает компилятору какой тип [_семантику копирования_][`Copy`]. Если мы посмотрим на исходный код [реализации][copy code] этого трэйта, то можно увидеть специальный аттрибут `#[lang = "copy"]`, которые указывает на то, что это языковой предмет.

[`Copy`]: https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html
[copy code]: https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src/libcore/marker.rs#L296-L299

Хотя создание собственных реализаций языковых предметов возможна, это следует делать только в крайнем случае. Причина в том, что языковые предметы являются крайне нестабильными частями реализации и даже не проверяются на тип (поэтому компилятор даже не проверяет, имеет ли функция правильные типы аргументов). К счастью, существует более стабильный способ исправить вышеупомянутую ошибку языкового предмета.

Языковой предмет [`eh_personality`][language item] указывает на функцию, которая используется для реализации [раскрутки стэка][stack unwinding]. По стандарту, Rust использует раскрутку для запуска деструктуров для всех _живых_ стэковых переменных в случае появлении [паники][panic]. Это гарантирует, что вся использованная память будет освобождена, и позволяет родительскому потоку перехватить панику и продолжить выполнение. Раскрутка очень сложный процесс и требует некоторых специльных библиотек ОС (например, [libunwind] для Linux или [structured exception handling] для Windows), так что мы не должны использовать их для нашей операицонной системы.

[language item]: https://github.com/rust-lang/rust/blob/edb368491551a77d77a48446d4ee88b35490c565/src/libpanic_unwind/gcc.rs#L11-L45
[stack unwinding]: https://www.bogotobogo.com/cplusplus/stackunwinding.php
[libunwind]: https://www.nongnu.org/libunwind/
[structured exception handling]: https://docs.microsoft.com/de-de/windows/win32/debug/structured-exception-handling

### Отключение раскрутки

Существуют и другие случаи использования, для которых раскрутка нежелательна, поэтому Rust предоставляет опцию [отмены при панике][abort on panic]. Это отключает генерацию информации о символах раскрутки и, таким образом, значительно уменьшает размер двоичного файла. Есть несколько мест, где мы можем отключить раскрутку. Самый простой способ - добавить следующие строки в наш `Cargo.toml`:

```toml
[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```

Это устанавливает стратегию паники на `abort`(отмены) как для профиля `dev` (используемого для `cargo build`), так и для профиля `release` (используемого для `cargo build --release`). Теперь языковой предмет `eh_personality` больше не должен требоваться.

[abort on panic]: https://github.com/rust-lang/rust/pull/32900

Теперь мы исправили обе вышеуказанные ошибки. Однако, если мы попытаемся скомпилировать его теперь, возникнет другая ошибка:

```
> cargo build
error: requires `start` lang_item
```

В нашей программе отсутствует языковой предмет `start`, который определяет начальную точку входа в программу.

## Аттрибут `start`

Можно подумать, что функция `main` - это первая функция, вызываемая при запуске программы. Однако в большинстве языков есть [runtime система][runtime system], которая отвечает за такие вещи, как сборка мусора (например, в Java) или программные потоки (например, goroutines в Go). Эта система выполнения должна быть вызвана до `main`, поскольку ей необходимо инициализировать себя.

[runtime system]: https://en.wikipedia.org/wiki/Runtime_system

В типичном бинарном файле Rust, который использует стандартную библиотеку, выполнение начинается в библиотеке C runtime под названием `crt0` ("C runtime zero"), которая создает окружение для C приложения. Это включает создание стека и размещение аргументов в нужных регистрах. Затем C runtime вызывает [точку входа для  приложения Rust][rt::lang_start], которая обозначается языковым предметом `start`. Rust имеет только очень маленький runtime, который заботится о некоторых мелочах, таких как установка защиты от переполнения стека или вывод сообщения при панике. Затем runtime вызывает функцию `main`.

[rt::lang_start]: https://github.com/rust-lang/rust/blob/bb4d1491466d8239a7a5fd68bd605e3276e97afb/src/libstd/rt.rs#L32-L73

Наш независимый исполняемый файл не имеет доступа к runtime Rust и `crt0`, поэтому нам нужно определить собственную точку входа. Реализация языкового предмета `start` не поможет, поскольку он все равно потребует `crt0`. Вместо этого нам нужно напрямую переопределить точку входа `crt0`.
